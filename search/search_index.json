{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Warren This site is a work in progress. Check out the links to the left to see what I'm working on. About the Name The Warren is a reference to one of my favorite book series of all time, Steven Erikson's Malazan Book of the Fallen . Let me echo the common refrain across the internet - if you can make it through the first book Gardens of the Moon with your interest intact, you'll love the rest of the series. I try to re-read it every year or two, and it's like getting back in touch with old friends.","title":"Home"},{"location":"#welcome-to-the-warren","text":"This site is a work in progress. Check out the links to the left to see what I'm working on.","title":"Welcome to the Warren"},{"location":"#about-the-name","text":"The Warren is a reference to one of my favorite book series of all time, Steven Erikson's Malazan Book of the Fallen . Let me echo the common refrain across the internet - if you can make it through the first book Gardens of the Moon with your interest intact, you'll love the rest of the series. I try to re-read it every year or two, and it's like getting back in touch with old friends.","title":"About the Name"},{"location":"other_musings/","text":"","title":"Other Musings"},{"location":"about/about/","text":"","title":"About Me"},{"location":"about/my_journey/","text":"","title":"My Journey"},{"location":"book_reviews/book_reviews/","text":"Book Reviews and Discussions I started my software development career after attending the Turing School of Software and Design where the focus was on getting new developers ready to hit the ground running at a job as quickly as possible. With only 24 hours in a day, it's hard to cover much of the fundamentals of software engineering. You can read more about my experience at Turing here . When I began my first job, I realized that there was a lot I didn't know about architecture, writing performant code, and the tradeoffs that that come with just about every decision you make designing software ( or that there is even a formalized method to explore those tradeoffs! ). It took a while before I started to address this lack of knowledge - settling into a new job in a new career field is an interesting experience all unto itself. Part of the solution to address my dearth of knowledge included figuring out what some of the more highly respected books in the field were. While I had been following the Coding Horror blog since college (and had read some of Jeff Atwood's recommended books ), I hadn't really gotten exposure to software engineering specific books. These articles are the result of my attempt to remedy that lack of knowledge. If you continue reading, you'll find my attempts to digest what I've read and hopefully put the result into something coherent. Domain Driven Design Quickly I decided to start with Domain Driven Design Quickly (DDDQ). This is a shorter version of the book Domain Driven Design . The free PDF of DDDQ was put together by InfoQ. The company I work for uses a lot of these concepts and they have broad appeal over most enterprise software. Chapters 1 and 2 What is Domain-Driven Design? The Ubiquitous Language Chapter 3 Model-Driven Design Chapters 4 and 5 Refactoring Towards Deeper Insight Preserving Model Integrity","title":"Purpose"},{"location":"book_reviews/book_reviews/#book-reviews-and-discussions","text":"I started my software development career after attending the Turing School of Software and Design where the focus was on getting new developers ready to hit the ground running at a job as quickly as possible. With only 24 hours in a day, it's hard to cover much of the fundamentals of software engineering. You can read more about my experience at Turing here . When I began my first job, I realized that there was a lot I didn't know about architecture, writing performant code, and the tradeoffs that that come with just about every decision you make designing software ( or that there is even a formalized method to explore those tradeoffs! ). It took a while before I started to address this lack of knowledge - settling into a new job in a new career field is an interesting experience all unto itself. Part of the solution to address my dearth of knowledge included figuring out what some of the more highly respected books in the field were. While I had been following the Coding Horror blog since college (and had read some of Jeff Atwood's recommended books ), I hadn't really gotten exposure to software engineering specific books. These articles are the result of my attempt to remedy that lack of knowledge. If you continue reading, you'll find my attempts to digest what I've read and hopefully put the result into something coherent.","title":"Book Reviews and Discussions"},{"location":"book_reviews/book_reviews/#domain-driven-design-quickly","text":"I decided to start with Domain Driven Design Quickly (DDDQ). This is a shorter version of the book Domain Driven Design . The free PDF of DDDQ was put together by InfoQ. The company I work for uses a lot of these concepts and they have broad appeal over most enterprise software.","title":"Domain Driven Design Quickly"},{"location":"book_reviews/book_reviews/#chapters-1-and-2","text":"What is Domain-Driven Design? The Ubiquitous Language","title":"Chapters 1 and 2"},{"location":"book_reviews/book_reviews/#chapter-3","text":"Model-Driven Design","title":"Chapter 3"},{"location":"book_reviews/book_reviews/#chapters-4-and-5","text":"Refactoring Towards Deeper Insight Preserving Model Integrity","title":"Chapters 4 and 5"},{"location":"book_reviews/domain_driven_design_quickly/chapter_3/","text":"Chapter 3 Model Driven Design In Chapter 3, the author really dives into the essence of domain driven design. One of the key concepts wrapped up into DDD is the idea of a model . This is an idea that is everpresent where software is written. One approach used to design software is the analysis model approach. The author points out that this very formal approach is typically done by a different set of people, most likely without taking into account the software developers or even software concepts. A common issue as these formal models get translated into software is performance. In order to squeeze higher performance out of software, there is occasionally a need to structure the objects and processes in that software in a certain way to allow things like parallelism, concurrency, or asynchronicity . Other issues pointed out by the author include analyst who may have gone into too much detail with some of the components of the model, and have not detailed enough others along with discovering details during the development phase that cause models to have to be rearranged or shifted. Another common issue with this approach is the loss of domain knowledge as the model is passed to the developers. Why have the analysts spend a large amount of time with the domain experts crafting the model only to then pass some of that knowledge along? Analysts can be valuable to this process; there should be a focus on developers being a large part of the process too. The Building Blocks of Model Driven Design In general most applications have a similar structure, colloquially referred to as a layered architecture . The layers serve as logical dividers from the different purposes of the software, although often some layers will be part of a monolithic whole. However, the author stresses that those layers should include models and processes that are as uncoupled as possible from the other layers and ideas like business logic. A common layered architecture might look like this: While this isn't the place to get into monoliths vs microservices , a layered architecture can be one or the other (or maybe a little of... both? That's a bad idea). The main idea here is that if conceptually you divide your layers and use separate models in each one without intertwining them too tightly, you can keep to the idea of a multi-layered architecture in a monolithic app. Entities, Value Objects and Services Entities Entities play a central role in domain driven design. A key portion of what makes an object an entity is identity; if we create a person object, that person should have a unique identifier so we can keep track of them throught the operations of the system. When an object is distinguished by its identity, rather than its attributes, make this primary to its definition in the model. Keep the class definition simple and focused on life cycle continuity and identity. Value Objects Value Objects are the next pattern that is discussed. One of the most important aspects of a value object is immutability . They should be easy to create and easy to throw away. If a different value is needed, simply create a new object rather than changing the one you have. Value Objects are the workhorse of DDD - they can contain references to Entities, references to other Value Objects, a long list of attributes, or anything in between. The author makes a point, however, to say Attributes chosen to make up a Value Object should form a conceptual whole. Services Services typically start as the actions of the domain, or verbs used by the domain experts. Use an object to contain these actions so that they can operate across multiple different Entities and Value Objects. For example, to transfer money from one account to another; should that function be in the sending account or the receiving account? Ensure that Services are grouped according to function so that they \" encapsulate a concept\" . The author points out that there are three characteristics of a Service The operation performed by the Service refers to a domain concept which does not naturally belong to an Entity or Value Object. The operation performed refers to other objects in the domain. The operation is stateless. A common mistake is to transpose Services from the domain layer into the infrastructure layer or vice versa. Don't be afraid to put Services in the application layer; where a Service lives is very dependant on the domain and the problem you are solving. The main thrust of this part of the book is to ensure that conceptually all of the aforementioned objects are separated. Continue on to the next post about Chapter 3 ...","title":"Chapter 3"},{"location":"book_reviews/domain_driven_design_quickly/chapter_3/#chapter-3","text":"","title":"Chapter 3"},{"location":"book_reviews/domain_driven_design_quickly/chapter_3/#model-driven-design","text":"In Chapter 3, the author really dives into the essence of domain driven design. One of the key concepts wrapped up into DDD is the idea of a model . This is an idea that is everpresent where software is written. One approach used to design software is the analysis model approach. The author points out that this very formal approach is typically done by a different set of people, most likely without taking into account the software developers or even software concepts. A common issue as these formal models get translated into software is performance. In order to squeeze higher performance out of software, there is occasionally a need to structure the objects and processes in that software in a certain way to allow things like parallelism, concurrency, or asynchronicity . Other issues pointed out by the author include analyst who may have gone into too much detail with some of the components of the model, and have not detailed enough others along with discovering details during the development phase that cause models to have to be rearranged or shifted. Another common issue with this approach is the loss of domain knowledge as the model is passed to the developers. Why have the analysts spend a large amount of time with the domain experts crafting the model only to then pass some of that knowledge along? Analysts can be valuable to this process; there should be a focus on developers being a large part of the process too.","title":"Model Driven Design"},{"location":"book_reviews/domain_driven_design_quickly/chapter_3/#the-building-blocks-of-model-driven-design","text":"In general most applications have a similar structure, colloquially referred to as a layered architecture . The layers serve as logical dividers from the different purposes of the software, although often some layers will be part of a monolithic whole. However, the author stresses that those layers should include models and processes that are as uncoupled as possible from the other layers and ideas like business logic. A common layered architecture might look like this: While this isn't the place to get into monoliths vs microservices , a layered architecture can be one or the other (or maybe a little of... both? That's a bad idea). The main idea here is that if conceptually you divide your layers and use separate models in each one without intertwining them too tightly, you can keep to the idea of a multi-layered architecture in a monolithic app.","title":"The Building Blocks of Model Driven Design"},{"location":"book_reviews/domain_driven_design_quickly/chapter_3/#entities-value-objects-and-services","text":"","title":"Entities, Value Objects and Services"},{"location":"book_reviews/domain_driven_design_quickly/chapter_3/#entities","text":"Entities play a central role in domain driven design. A key portion of what makes an object an entity is identity; if we create a person object, that person should have a unique identifier so we can keep track of them throught the operations of the system. When an object is distinguished by its identity, rather than its attributes, make this primary to its definition in the model. Keep the class definition simple and focused on life cycle continuity and identity.","title":"Entities"},{"location":"book_reviews/domain_driven_design_quickly/chapter_3/#value-objects","text":"Value Objects are the next pattern that is discussed. One of the most important aspects of a value object is immutability . They should be easy to create and easy to throw away. If a different value is needed, simply create a new object rather than changing the one you have. Value Objects are the workhorse of DDD - they can contain references to Entities, references to other Value Objects, a long list of attributes, or anything in between. The author makes a point, however, to say Attributes chosen to make up a Value Object should form a conceptual whole.","title":"Value Objects"},{"location":"book_reviews/domain_driven_design_quickly/chapter_3/#services","text":"Services typically start as the actions of the domain, or verbs used by the domain experts. Use an object to contain these actions so that they can operate across multiple different Entities and Value Objects. For example, to transfer money from one account to another; should that function be in the sending account or the receiving account? Ensure that Services are grouped according to function so that they \" encapsulate a concept\" . The author points out that there are three characteristics of a Service The operation performed by the Service refers to a domain concept which does not naturally belong to an Entity or Value Object. The operation performed refers to other objects in the domain. The operation is stateless. A common mistake is to transpose Services from the domain layer into the infrastructure layer or vice versa. Don't be afraid to put Services in the application layer; where a Service lives is very dependant on the domain and the problem you are solving. The main thrust of this part of the book is to ensure that conceptually all of the aforementioned objects are separated. Continue on to the next post about Chapter 3 ...","title":"Services"},{"location":"book_reviews/domain_driven_design_quickly/chapter_3_part_2/","text":"Chapter 3 (Part 2) Modules Modules are an important factor in domain driven design - creating Modules that are well designed and cohesive is a large step towards writing clear and maintainable code. The parts of a Module should attempt to follow the idea of functional cohesion . Ensure you are considering how tightly coupled the Modules are with themselves and the rest of the application. A low level of coupling is something to work towards; this can also make the move to microservies much easier at a later date if so desired. An important piece of advice the author recommends is to the Modules names that become part of the Ubiquitous Language. Modules and their names should reflect insight into the domain. For examples of tight versus loose coupling, think of the API of a bank. If the banks software is written for only one front end or client (in the programming sense, not the business sense), then we can consider the backend and frontend of that API tightly coupled . Now the bank has decided to let customers pull their own data about their accounts - this will require a redesign of the API of the backend in order to allow connections from different users, not just the single integrated front end. We can now say the system is loosely coupled . Aggregates, Factories, and Repositories Aggregates The last three parts of Chapter 3 cover the life cycle of domain objects. Objects in your application will be created, used throughout the application, and then destroyed when they are no longer needed. These three concepts help to establish some of the aspects of that cycle. Aggregates are a group of associated objects which are considered as one unit with regard to data changes. Each Aggregate has exactly one root. The root of the Aggregate is an Entity; the Entity is the only publicly accessible object of the Aggreggate. Internal objects inside the Aggregate can hold references to other internal objects or Entities that are entirely internal to the Aggregate. Nothing outside of the boundary of the Aggregate should hold a reference to anything except the root of the Aggregate. For example, with a customer object at the root of the Aggregate, there could be internal references to a contact info object, address object, or a spouse object. If an external object needs that information, the root of the Aggregate could pass a transient reference to the internal object, often in the form of a Value Object. Factories A Factory is exactly what it sounds like - a mechanism to create complex objects. In order to create complex objects without a Factory, the calling object would often need to have intimate knowledge about the object it is attempting to create. This breaks multiple principles of DDD (and Object Oriented Programming principles ). An important part of this object creation is atomicity . Specifically, there should never be a half-created object, only no object or a whole object. The Aggregate should have a method that utilizes the Factory to create the objects that make up the Aggregate. This creation process will enforce the invariants of the different objects to ensure that the resulting object is valid. While it is true that Factories are tightly coupled to the objects they create, this can be a strength in that it gives you a single place to concentrate your creation logic. Sometimes, a simple constructor is enough; use a constructor when: The construction is not complicated. The creation of an object does not involve the creation of others, and all the attributes needed are passed via the constructor. The client is interested in the implementation, perhaps wants to choose the Strategy used. The class is the type. There is no hierarchy involved, so no need to choose between a list of concrete implementations. In order to retain Entity integrity, ensure that any violation of an invariant returns an exception. When creating an object from the database, if there is a violation of an invariant, that violation must be repaired before being used to generate the object. For example, if another process has added a number to a string in the database that should be restricted to only alpha characters, this should be resolved before creating that object (this is a fairly contrived example, but hopefully you get the picture). Repositories The hypothetical scenario presented by the author to explain the need for Repositories is this: if a client needs to obtain the reference to an Aggregate, it needs a reference to the root of that aggregate. While this can be obtained by assocatiation traversal , this sometimes forces object to hold references they would not normally hold. Another common way to make this happen is to let the client pull the Entity directly from the database; this is generally a bad idea as it requires the clients or the objects the clients request to be aware of how to access the database. What if you change the underlying infrastructure or database? Now all of that scattered code must be changed as well. In order to alleviate these concerns, the author introduces the Repository pattern. The Repository may store references to some of the objects. When an object is created, it may be saved in the Repository, and retrieved from there to be used later. If the client requested an object from the Repository, and the Repository does not have it, it may get it from the storage. Either way, the Repository acts as a storage place for globally accessible objects. Many applications use a caching system to serve the role of the repository. Caches give the application easy and quick access to the different objects generated by the Factories. Repositories should also be able to request an object be created by a Factory. The Repository can be likened to infrastructure, but it should remain purely in the domain. It should have links to the infrastructure layer in order to obtain objects from the database if needed; it should not, however, be tightly coupled to the infrastructure. Check out the next couple chapters here!","title":"Chapter 3 (Part 2)"},{"location":"book_reviews/domain_driven_design_quickly/chapter_3_part_2/#chapter-3-part-2","text":"","title":"Chapter 3 (Part 2)"},{"location":"book_reviews/domain_driven_design_quickly/chapter_3_part_2/#modules","text":"Modules are an important factor in domain driven design - creating Modules that are well designed and cohesive is a large step towards writing clear and maintainable code. The parts of a Module should attempt to follow the idea of functional cohesion . Ensure you are considering how tightly coupled the Modules are with themselves and the rest of the application. A low level of coupling is something to work towards; this can also make the move to microservies much easier at a later date if so desired. An important piece of advice the author recommends is to the Modules names that become part of the Ubiquitous Language. Modules and their names should reflect insight into the domain. For examples of tight versus loose coupling, think of the API of a bank. If the banks software is written for only one front end or client (in the programming sense, not the business sense), then we can consider the backend and frontend of that API tightly coupled . Now the bank has decided to let customers pull their own data about their accounts - this will require a redesign of the API of the backend in order to allow connections from different users, not just the single integrated front end. We can now say the system is loosely coupled .","title":"Modules"},{"location":"book_reviews/domain_driven_design_quickly/chapter_3_part_2/#aggregates-factories-and-repositories","text":"","title":"Aggregates, Factories, and Repositories"},{"location":"book_reviews/domain_driven_design_quickly/chapter_3_part_2/#aggregates","text":"The last three parts of Chapter 3 cover the life cycle of domain objects. Objects in your application will be created, used throughout the application, and then destroyed when they are no longer needed. These three concepts help to establish some of the aspects of that cycle. Aggregates are a group of associated objects which are considered as one unit with regard to data changes. Each Aggregate has exactly one root. The root of the Aggregate is an Entity; the Entity is the only publicly accessible object of the Aggreggate. Internal objects inside the Aggregate can hold references to other internal objects or Entities that are entirely internal to the Aggregate. Nothing outside of the boundary of the Aggregate should hold a reference to anything except the root of the Aggregate. For example, with a customer object at the root of the Aggregate, there could be internal references to a contact info object, address object, or a spouse object. If an external object needs that information, the root of the Aggregate could pass a transient reference to the internal object, often in the form of a Value Object.","title":"Aggregates"},{"location":"book_reviews/domain_driven_design_quickly/chapter_3_part_2/#factories","text":"A Factory is exactly what it sounds like - a mechanism to create complex objects. In order to create complex objects without a Factory, the calling object would often need to have intimate knowledge about the object it is attempting to create. This breaks multiple principles of DDD (and Object Oriented Programming principles ). An important part of this object creation is atomicity . Specifically, there should never be a half-created object, only no object or a whole object. The Aggregate should have a method that utilizes the Factory to create the objects that make up the Aggregate. This creation process will enforce the invariants of the different objects to ensure that the resulting object is valid. While it is true that Factories are tightly coupled to the objects they create, this can be a strength in that it gives you a single place to concentrate your creation logic. Sometimes, a simple constructor is enough; use a constructor when: The construction is not complicated. The creation of an object does not involve the creation of others, and all the attributes needed are passed via the constructor. The client is interested in the implementation, perhaps wants to choose the Strategy used. The class is the type. There is no hierarchy involved, so no need to choose between a list of concrete implementations. In order to retain Entity integrity, ensure that any violation of an invariant returns an exception. When creating an object from the database, if there is a violation of an invariant, that violation must be repaired before being used to generate the object. For example, if another process has added a number to a string in the database that should be restricted to only alpha characters, this should be resolved before creating that object (this is a fairly contrived example, but hopefully you get the picture).","title":"Factories"},{"location":"book_reviews/domain_driven_design_quickly/chapter_3_part_2/#repositories","text":"The hypothetical scenario presented by the author to explain the need for Repositories is this: if a client needs to obtain the reference to an Aggregate, it needs a reference to the root of that aggregate. While this can be obtained by assocatiation traversal , this sometimes forces object to hold references they would not normally hold. Another common way to make this happen is to let the client pull the Entity directly from the database; this is generally a bad idea as it requires the clients or the objects the clients request to be aware of how to access the database. What if you change the underlying infrastructure or database? Now all of that scattered code must be changed as well. In order to alleviate these concerns, the author introduces the Repository pattern. The Repository may store references to some of the objects. When an object is created, it may be saved in the Repository, and retrieved from there to be used later. If the client requested an object from the Repository, and the Repository does not have it, it may get it from the storage. Either way, the Repository acts as a storage place for globally accessible objects. Many applications use a caching system to serve the role of the repository. Caches give the application easy and quick access to the different objects generated by the Factories. Repositories should also be able to request an object be created by a Factory. The Repository can be likened to infrastructure, but it should remain purely in the domain. It should have links to the infrastructure layer in order to obtain objects from the database if needed; it should not, however, be tightly coupled to the infrastructure. Check out the next couple chapters here!","title":"Repositories"},{"location":"book_reviews/domain_driven_design_quickly/chapters_1_and_2/","text":"Chapters 1 and 2 What is Domain Driven Design? Domain driven design is a concept that seems obvious in hindsight. As one of the first examples in the books says: consider making software for banking. While the common concepts of banking are something that probably comes readily to your mind, developing software that must hit the different edge cases and out of the ordinary scenarios is a complicated task. Even the normal operations of debits and credits and accounts can get extremely complicated once the concept of scale PDF is introduced to the equation. Understanding the domain well is one of the keys to writing software that solves problems. It makes sense that software that works with the domain performs better than software that doesn't. As an aside - there are different types of \"design philosophies\" in the software industry. Test driven development , behavior driven development , and design driven development are all different approaches to the same problem - how to develop good software. Even further, how to develop good software that solves a problem. (And let's remember, programming is hard! ) Understanding the Domain Having an understanding of the domain is key to designing good software. There are multitudes of software applications and companies that have failed precisely because they neglected to let the domain experts inform their design. It is all too easy for software developers to fall into what I call the consultant's trap - when you believe you're the smartest person in the room, it's easy to discount the advice or knowledge of everyone else . That's an easy path to bottom. There is some discussion on agile versus waterfall development strategies. The upsides and downsides of both of those types of development strategies have been legislated ad nauseum; suffice it to say that agile software development strategies dovetail very nicely with the knowledge gaining and domain exploring that's inherent in domain driven design. Having an iterative process to accomplish both of those aspects allows the developers and the domain experts to quickly establish a rapport and start building a knowledge base. Utilize the Experts The emphasis on working with domain experts continues on in the first chapter. The main example used throughout the book is of an airplane flight control system. You probably know how the basics of airplane flight control work - a plane starts at a departure or origin, follows some path through the air, and then lands at a destination. However, this doesn't cover even the smallest bit of complexity that's involved. What if there are multiple planes landing at near the same times? What about inclement weather changing flight paths? What about emergencies? All of these scenarios happen every day and this hypothetical software may have to handle them. As the discussion between the developer and the domain expert about basic ideas, scenarios, and potential edge cases is under way, something interesting is happening; they are developing the Ubiquitous Language . The Ubiquitous Language Early on in Chapter 2, the author points out that A core principle of domain-driven design is to use a language based on the model. Since the model is the common ground, the place where the software meets the domain, it is appropriate to use it as the building ground for this language. He continues on to exmplain that software developers and managers should Make sure this language appears consistently in all the communication forms used by the team; for this reason, the language is called the Ubiquitous Language. Martin Fowler has a great article about homonyms , polysemy and it's affect on the Ubiquitous Language. In short, due to the ability of words to have multiple meanings depending on context, it's important to gather pieces of the Ubiquitous Language while working in coordination with the domain experts . These words and phrases should be as clear as possible. It can be difficult at times to ensure that the all important conversations with domain experts stay focused - the author recommends making sure the software team is always aware of the goal; namely, building a Ubiquitous Language. Use software or team centric jargon as little as possible and use the Ubiquitous Language as much as possible to reinforce its usage in general. UML and Documentation The author talks about the tradeoffs of the Unified Modeling Language , or UML. UML can be extremely helpful when the number of elements involved isn't too large. However, in larger software projects, it would be detrimental to have hundreds of UML diagrams. One of the points the author also makes is to be wary of long documents. As soon you write a document, there's a good chance it's going to be obsoleted very quickly. Be wary of this fact; keep your documentation in as close to lockstep with the application as possible, especially for system documentation . Documentation (along with programming) is hard ! It can be one of the stronger assets to an established team, however; give it the focus it needs. Check out the next chapter here!","title":"Chapters 1 and 2"},{"location":"book_reviews/domain_driven_design_quickly/chapters_1_and_2/#chapters-1-and-2","text":"","title":"Chapters 1 and 2"},{"location":"book_reviews/domain_driven_design_quickly/chapters_1_and_2/#what-is-domain-driven-design","text":"Domain driven design is a concept that seems obvious in hindsight. As one of the first examples in the books says: consider making software for banking. While the common concepts of banking are something that probably comes readily to your mind, developing software that must hit the different edge cases and out of the ordinary scenarios is a complicated task. Even the normal operations of debits and credits and accounts can get extremely complicated once the concept of scale PDF is introduced to the equation. Understanding the domain well is one of the keys to writing software that solves problems. It makes sense that software that works with the domain performs better than software that doesn't. As an aside - there are different types of \"design philosophies\" in the software industry. Test driven development , behavior driven development , and design driven development are all different approaches to the same problem - how to develop good software. Even further, how to develop good software that solves a problem. (And let's remember, programming is hard! )","title":"What is Domain Driven Design?"},{"location":"book_reviews/domain_driven_design_quickly/chapters_1_and_2/#understanding-the-domain","text":"Having an understanding of the domain is key to designing good software. There are multitudes of software applications and companies that have failed precisely because they neglected to let the domain experts inform their design. It is all too easy for software developers to fall into what I call the consultant's trap - when you believe you're the smartest person in the room, it's easy to discount the advice or knowledge of everyone else . That's an easy path to bottom. There is some discussion on agile versus waterfall development strategies. The upsides and downsides of both of those types of development strategies have been legislated ad nauseum; suffice it to say that agile software development strategies dovetail very nicely with the knowledge gaining and domain exploring that's inherent in domain driven design. Having an iterative process to accomplish both of those aspects allows the developers and the domain experts to quickly establish a rapport and start building a knowledge base.","title":"Understanding the Domain"},{"location":"book_reviews/domain_driven_design_quickly/chapters_1_and_2/#utilize-the-experts","text":"The emphasis on working with domain experts continues on in the first chapter. The main example used throughout the book is of an airplane flight control system. You probably know how the basics of airplane flight control work - a plane starts at a departure or origin, follows some path through the air, and then lands at a destination. However, this doesn't cover even the smallest bit of complexity that's involved. What if there are multiple planes landing at near the same times? What about inclement weather changing flight paths? What about emergencies? All of these scenarios happen every day and this hypothetical software may have to handle them. As the discussion between the developer and the domain expert about basic ideas, scenarios, and potential edge cases is under way, something interesting is happening; they are developing the Ubiquitous Language .","title":"Utilize the Experts"},{"location":"book_reviews/domain_driven_design_quickly/chapters_1_and_2/#the-ubiquitous-language","text":"Early on in Chapter 2, the author points out that A core principle of domain-driven design is to use a language based on the model. Since the model is the common ground, the place where the software meets the domain, it is appropriate to use it as the building ground for this language. He continues on to exmplain that software developers and managers should Make sure this language appears consistently in all the communication forms used by the team; for this reason, the language is called the Ubiquitous Language. Martin Fowler has a great article about homonyms , polysemy and it's affect on the Ubiquitous Language. In short, due to the ability of words to have multiple meanings depending on context, it's important to gather pieces of the Ubiquitous Language while working in coordination with the domain experts . These words and phrases should be as clear as possible. It can be difficult at times to ensure that the all important conversations with domain experts stay focused - the author recommends making sure the software team is always aware of the goal; namely, building a Ubiquitous Language. Use software or team centric jargon as little as possible and use the Ubiquitous Language as much as possible to reinforce its usage in general.","title":"The Ubiquitous Language"},{"location":"book_reviews/domain_driven_design_quickly/chapters_1_and_2/#uml-and-documentation","text":"The author talks about the tradeoffs of the Unified Modeling Language , or UML. UML can be extremely helpful when the number of elements involved isn't too large. However, in larger software projects, it would be detrimental to have hundreds of UML diagrams. One of the points the author also makes is to be wary of long documents. As soon you write a document, there's a good chance it's going to be obsoleted very quickly. Be wary of this fact; keep your documentation in as close to lockstep with the application as possible, especially for system documentation . Documentation (along with programming) is hard ! It can be one of the stronger assets to an established team, however; give it the focus it needs. Check out the next chapter here!","title":"UML and Documentation"},{"location":"book_reviews/domain_driven_design_quickly/chapters_4_and_5/","text":"Chapters 4 and 5","title":"Chapters 4 and 5"},{"location":"book_reviews/domain_driven_design_quickly/chapters_4_and_5/#chapters-4-and-5","text":"","title":"Chapters 4 and 5"},{"location":"other_musings/host_a_book_club/","text":"","title":"Host a book club"}]}